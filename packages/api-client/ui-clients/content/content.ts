/**
 * Generated by orval v7.21.0 ðŸº
 * Do not edit manually.
 * Business Pro API
 * AI-driven social media automation platform for local businesses
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  ContentControllerFindAllParams,
  ContentControllerGetRecentParams,
  ContentControllerGetScheduledParams,
  CreateContentDtoDTO,
  UpdateContentDtoDTO,
} from '.././schemas';

import { customAxiosInstance } from '.././axios-instance';

/**
 * @summary Create new content
 */
export const contentControllerCreate = (
  createContentDtoDTO: CreateContentDtoDTO,
  signal?: AbortSignal,
) => {
  return customAxiosInstance<void>({
    url: `/api/v1/content`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createContentDtoDTO,
    signal,
  });
};

export const getContentControllerCreateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof contentControllerCreate>>,
    TError,
    { data: CreateContentDtoDTO },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof contentControllerCreate>>,
  TError,
  { data: CreateContentDtoDTO },
  TContext
> => {
  const mutationKey = ['contentControllerCreate'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof contentControllerCreate>>,
    { data: CreateContentDtoDTO }
  > = props => {
    const { data } = props ?? {};

    return contentControllerCreate(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContentControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof contentControllerCreate>>
>;
export type ContentControllerCreateMutationBody = CreateContentDtoDTO;
export type ContentControllerCreateMutationError = unknown;

/**
 * @summary Create new content
 */
export const useContentControllerCreate = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof contentControllerCreate>>,
    TError,
    { data: CreateContentDtoDTO },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof contentControllerCreate>>,
  TError,
  { data: CreateContentDtoDTO },
  TContext
> => {
  const mutationOptions = getContentControllerCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Get all content with filters and pagination
 */
export const contentControllerFindAll = (
  params?: ContentControllerFindAllParams,
  signal?: AbortSignal,
) => {
  return customAxiosInstance<void>({ url: `/api/v1/content`, method: 'GET', params, signal });
};

export const getContentControllerFindAllQueryKey = (params?: ContentControllerFindAllParams) => {
  return [`/api/v1/content`, ...(params ? [params] : [])] as const;
};

export const getContentControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof contentControllerFindAll>>,
  TError = unknown,
>(
  params?: ContentControllerFindAllParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof contentControllerFindAll>>, TError, TData>;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getContentControllerFindAllQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof contentControllerFindAll>>> = ({
    signal,
  }) => contentControllerFindAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof contentControllerFindAll>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ContentControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof contentControllerFindAll>>
>;
export type ContentControllerFindAllQueryError = unknown;

/**
 * @summary Get all content with filters and pagination
 */

export function useContentControllerFindAll<
  TData = Awaited<ReturnType<typeof contentControllerFindAll>>,
  TError = unknown,
>(
  params?: ContentControllerFindAllParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof contentControllerFindAll>>, TError, TData>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getContentControllerFindAllQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get content statistics
 */
export const contentControllerGetStats = (signal?: AbortSignal) => {
  return customAxiosInstance<void>({ url: `/api/v1/content/stats`, method: 'GET', signal });
};

export const getContentControllerGetStatsQueryKey = () => {
  return [`/api/v1/content/stats`] as const;
};

export const getContentControllerGetStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof contentControllerGetStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof contentControllerGetStats>>, TError, TData>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getContentControllerGetStatsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof contentControllerGetStats>>> = ({
    signal,
  }) => contentControllerGetStats(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof contentControllerGetStats>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ContentControllerGetStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof contentControllerGetStats>>
>;
export type ContentControllerGetStatsQueryError = unknown;

/**
 * @summary Get content statistics
 */

export function useContentControllerGetStats<
  TData = Awaited<ReturnType<typeof contentControllerGetStats>>,
  TError = unknown,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof contentControllerGetStats>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getContentControllerGetStatsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get recent content
 */
export const contentControllerGetRecent = (
  params?: ContentControllerGetRecentParams,
  signal?: AbortSignal,
) => {
  return customAxiosInstance<void>({
    url: `/api/v1/content/recent`,
    method: 'GET',
    params,
    signal,
  });
};

export const getContentControllerGetRecentQueryKey = (
  params?: ContentControllerGetRecentParams,
) => {
  return [`/api/v1/content/recent`, ...(params ? [params] : [])] as const;
};

export const getContentControllerGetRecentQueryOptions = <
  TData = Awaited<ReturnType<typeof contentControllerGetRecent>>,
  TError = unknown,
>(
  params?: ContentControllerGetRecentParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof contentControllerGetRecent>>, TError, TData>;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getContentControllerGetRecentQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof contentControllerGetRecent>>> = ({
    signal,
  }) => contentControllerGetRecent(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof contentControllerGetRecent>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ContentControllerGetRecentQueryResult = NonNullable<
  Awaited<ReturnType<typeof contentControllerGetRecent>>
>;
export type ContentControllerGetRecentQueryError = unknown;

/**
 * @summary Get recent content
 */

export function useContentControllerGetRecent<
  TData = Awaited<ReturnType<typeof contentControllerGetRecent>>,
  TError = unknown,
>(
  params?: ContentControllerGetRecentParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof contentControllerGetRecent>>, TError, TData>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getContentControllerGetRecentQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get scheduled content for date range
 */
export const contentControllerGetScheduled = (
  params: ContentControllerGetScheduledParams,
  signal?: AbortSignal,
) => {
  return customAxiosInstance<void>({
    url: `/api/v1/content/scheduled`,
    method: 'GET',
    params,
    signal,
  });
};

export const getContentControllerGetScheduledQueryKey = (
  params?: ContentControllerGetScheduledParams,
) => {
  return [`/api/v1/content/scheduled`, ...(params ? [params] : [])] as const;
};

export const getContentControllerGetScheduledQueryOptions = <
  TData = Awaited<ReturnType<typeof contentControllerGetScheduled>>,
  TError = unknown,
>(
  params: ContentControllerGetScheduledParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof contentControllerGetScheduled>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getContentControllerGetScheduledQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof contentControllerGetScheduled>>> = ({
    signal,
  }) => contentControllerGetScheduled(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof contentControllerGetScheduled>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ContentControllerGetScheduledQueryResult = NonNullable<
  Awaited<ReturnType<typeof contentControllerGetScheduled>>
>;
export type ContentControllerGetScheduledQueryError = unknown;

/**
 * @summary Get scheduled content for date range
 */

export function useContentControllerGetScheduled<
  TData = Awaited<ReturnType<typeof contentControllerGetScheduled>>,
  TError = unknown,
>(
  params: ContentControllerGetScheduledParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof contentControllerGetScheduled>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getContentControllerGetScheduledQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get content by ID
 */
export const contentControllerFindOne = (id: string, signal?: AbortSignal) => {
  return customAxiosInstance<void>({ url: `/api/v1/content/${id}`, method: 'GET', signal });
};

export const getContentControllerFindOneQueryKey = (id?: string) => {
  return [`/api/v1/content/${id}`] as const;
};

export const getContentControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof contentControllerFindOne>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof contentControllerFindOne>>, TError, TData>;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getContentControllerFindOneQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof contentControllerFindOne>>> = ({
    signal,
  }) => contentControllerFindOne(id, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof contentControllerFindOne>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type ContentControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof contentControllerFindOne>>
>;
export type ContentControllerFindOneQueryError = void;

/**
 * @summary Get content by ID
 */

export function useContentControllerFindOne<
  TData = Awaited<ReturnType<typeof contentControllerFindOne>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof contentControllerFindOne>>, TError, TData>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getContentControllerFindOneQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update content
 */
export const contentControllerUpdate = (id: string, updateContentDtoDTO: UpdateContentDtoDTO) => {
  return customAxiosInstance<void>({
    url: `/api/v1/content/${id}`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: updateContentDtoDTO,
  });
};

export const getContentControllerUpdateMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof contentControllerUpdate>>,
    TError,
    { id: string; data: UpdateContentDtoDTO },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof contentControllerUpdate>>,
  TError,
  { id: string; data: UpdateContentDtoDTO },
  TContext
> => {
  const mutationKey = ['contentControllerUpdate'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof contentControllerUpdate>>,
    { id: string; data: UpdateContentDtoDTO }
  > = props => {
    const { id, data } = props ?? {};

    return contentControllerUpdate(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContentControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof contentControllerUpdate>>
>;
export type ContentControllerUpdateMutationBody = UpdateContentDtoDTO;
export type ContentControllerUpdateMutationError = void;

/**
 * @summary Update content
 */
export const useContentControllerUpdate = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof contentControllerUpdate>>,
    TError,
    { id: string; data: UpdateContentDtoDTO },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof contentControllerUpdate>>,
  TError,
  { id: string; data: UpdateContentDtoDTO },
  TContext
> => {
  const mutationOptions = getContentControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Delete content (soft delete)
 */
export const contentControllerRemove = (id: string) => {
  return customAxiosInstance<void>({ url: `/api/v1/content/${id}`, method: 'DELETE' });
};

export const getContentControllerRemoveMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof contentControllerRemove>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof contentControllerRemove>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['contentControllerRemove'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof contentControllerRemove>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return contentControllerRemove(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContentControllerRemoveMutationResult = NonNullable<
  Awaited<ReturnType<typeof contentControllerRemove>>
>;

export type ContentControllerRemoveMutationError = void;

/**
 * @summary Delete content (soft delete)
 */
export const useContentControllerRemove = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof contentControllerRemove>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof contentControllerRemove>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getContentControllerRemoveMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Duplicate content
 */
export const contentControllerDuplicate = (id: string, signal?: AbortSignal) => {
  return customAxiosInstance<void>({
    url: `/api/v1/content/${id}/duplicate`,
    method: 'POST',
    signal,
  });
};

export const getContentControllerDuplicateMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof contentControllerDuplicate>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof contentControllerDuplicate>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['contentControllerDuplicate'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof contentControllerDuplicate>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return contentControllerDuplicate(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContentControllerDuplicateMutationResult = NonNullable<
  Awaited<ReturnType<typeof contentControllerDuplicate>>
>;

export type ContentControllerDuplicateMutationError = void;

/**
 * @summary Duplicate content
 */
export const useContentControllerDuplicate = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof contentControllerDuplicate>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof contentControllerDuplicate>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getContentControllerDuplicateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Publish content immediately
 */
export const contentControllerPublish = (id: string, signal?: AbortSignal) => {
  return customAxiosInstance<void>({
    url: `/api/v1/content/${id}/publish`,
    method: 'POST',
    signal,
  });
};

export const getContentControllerPublishMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof contentControllerPublish>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof contentControllerPublish>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['contentControllerPublish'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof contentControllerPublish>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return contentControllerPublish(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContentControllerPublishMutationResult = NonNullable<
  Awaited<ReturnType<typeof contentControllerPublish>>
>;

export type ContentControllerPublishMutationError = void;

/**
 * @summary Publish content immediately
 */
export const useContentControllerPublish = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof contentControllerPublish>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof contentControllerPublish>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getContentControllerPublishMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * @summary Reschedule content
 */
export const contentControllerReschedule = (id: string) => {
  return customAxiosInstance<void>({ url: `/api/v1/content/${id}/reschedule`, method: 'PATCH' });
};

export const getContentControllerRescheduleMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof contentControllerReschedule>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof contentControllerReschedule>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['contentControllerReschedule'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof contentControllerReschedule>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return contentControllerReschedule(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContentControllerRescheduleMutationResult = NonNullable<
  Awaited<ReturnType<typeof contentControllerReschedule>>
>;

export type ContentControllerRescheduleMutationError = void;

/**
 * @summary Reschedule content
 */
export const useContentControllerReschedule = <TError = void, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof contentControllerReschedule>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof contentControllerReschedule>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getContentControllerRescheduleMutationOptions(options);

  return useMutation(mutationOptions);
};
